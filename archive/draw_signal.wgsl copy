struct Parameters {
  inner_window_offset: vec2<f32>,
  outer_window_resolution: vec2<f32>,
  inner_window_resolution: vec2<i32>
};


@group(0) @binding(0) var<uniform> params : Parameters;
@group(1) @binding(0) var<storage, read> signals : array<f32>;



@vertex
fn vs_main(@builtin(vertex_index) vertex_index: u32) -> @builtin(position) vec4<f32> {
    // var out: vec2<f32>;

    let m = vertex_index % u32(3) + (vertex_index / u32(3));

    var x = f32(i32((m << u32(1)) & u32(2)));
    var y = f32(i32(m & u32(2)));
    var uv = vec2<f32>(x, y);
    uv.x *= .325;
    uv += params.inner_window_offset;

    return vec4<f32>(uv, 0.0, 1.0);;
}

fn mBall(uv: vec2<i32>, pos: vec2<i32>, radius: f32) -> f32
{
	return radius/f32(dot(uv-pos,uv-pos));
}

let mint = vec3<f32>(.0,1.,.5);
let resolution = vec2<i32>(1066, 1066);
let zone_3_size = vec2<i32>(100, 100);
let color_bg = vec3<f32>(0.22,0.0,0.0);
let color_inner = vec3<f32>(1.0,1.0,0.0);
let color_outer = vec3<f32>(0.5,0.8,0.3);

@fragment
fn fs_main( @builtin(position) frag_coord: vec4<f32>) -> @location(0) vec4<f32>{

    let signal_location_size = resolution / zone_3_size;
    //local UV coordinates
    let l_uv = vec2<i32>(frag_coord.xy) / signal_location_size;

    let total = arrayLength(&signals);
    let index = l_uv.y * zone_3_size.y + l_uv.x;
    if(index >= i32(total)){return vec4<f32>(color_bg, 1.);}

    let val = signals[index];

    var mb = 0.;
    if(signals[index] > 0.5){
        mb = mBall(l_uv, vec2<i32>(0, 0), signals[index]);
    }

    for(var row_offset: i32 = -1; row_offset < 2; row_offset++) {
        for(var column_offset: i32 = -1; column_offset < 2; column_offset++) {
            if(row_offset == 0 && column_offset == 0) { continue; }
            var neighbor = l_uv;

            neighbor.y = neighbor.y + row_offset;
            if(neighbor.y < 0) {neighbor.y = zone_3_size.y;}
            else if(neighbor.y > zone_3_size.y - 1) {neighbor.y = 0;}

            neighbor.x = neighbor.x + column_offset;
            if(neighbor.x < 0) {neighbor.x = zone_3_size.x - 1;}
            else if(neighbor.x == zone_3_size.x - 1) {neighbor.x = 0;}


            var neighbor_index = neighbor.y * zone_3_size.y + neighbor.x;

            if(signals[neighbor_index] > 0.5){
                mb = mb + mBall(l_uv, neighbor, signals[neighbor_index]);
            }
        }
    }

    let mbext = color_outer * (1.- smoothstep(mb, mb+0.01, 0.2)); // 0.5 for control the blob thickness
    let mbin = color_inner * (1.- smoothstep(mb, mb+0.01, 1.)); // 0.8 for control the blob kernel size

    return vec4<f32>(mbext+mbin+color_bg, 1.);

//    return vec4<f32>(mbin+mbext, 1.);
}